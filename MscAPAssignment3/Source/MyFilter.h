/*
  ==============================================================================

    MyFilter.h
    Created: Apr/May 2022
    Author: B191392

    This is a wrapper around the Juce provided filter and ADSR envelope classes
    to provide a filter section for the synth.
 
    The following parameters are used in this class:
 
    * filterOn: Determines if the filter will be applied or bypassed.
    * filterType: Specifies whether this should be a low or high pass filter.
    * filterAppliesTo: Specifies whether the frequency or the resonance factor will be affected by the envelope
    * filterFreq: Specifies the cutoff of the filter
    * filterQ: Specifies the resonance factor for the filter
    * filterAttack: Specifies the time for the filter to ramp up to full
    * filterDecay: Specifies the time for the filter to ramp down to the sustain value
    * filterSustain: Specifies the level the filter will remain at after decay and before release
    * filterRelease: Specifies the time for the filter to ramp down fulls after the note stops

 
  ==============================================================================
*/

#pragma once

#include "MyParameters.h"
#include <JuceHeader.h>

class MyFilter
{
public:
    /**
     Constructor for MyFilter
     
     @param _params A pointer to the user editable parameters.
     */
    MyFilter (MyParameters* _params) : params (_params)
    {
        // empty
    }

    /**
            Resets the filter when a new note is started. Must be called at the start of notes or else the filter will not work and could cause silence.
     */
    void startNote()
    {
        filter.reset();

        filterEnv.reset();
        filterEnv.noteOn();
    }

    /**
            Triggers the filter envelope to begin closing in the release phase. Must be called when the note is stopped or the filter will not close.
     */
    void stopNote()
    {
        filterEnv.noteOff();
    }

    
    /**
     Applies the filter to the given sample if the filter is turned on, otherwise returns the given sample untouched.
     
            This function also contains handling for the LFO which can be applied to the frequency or the resonance values. See updateParams for more.

     @param sampleRate The current sample rate, needed for correctly setting up the filter coefficients
     @param sample The sample to apply the filter to
     @param lfoAppliesToFilterFreq Specifies whether the LFO should be applied to the frequency
     @param lfoAppliesToFilterQ Specifies whether the LFO should be applied to the resonance
     @param lfoSample The relevant sample generated by the LFO
     */
    float apply (float sampleRate, float sample, bool lfoAppliesToFilterFreq, bool lfoAppliesToFilterQ, float lfoSample)
    {
        updateParams (sampleRate, lfoAppliesToFilterFreq, lfoAppliesToFilterQ, lfoSample);
        if (params->filterOn->get())
            return filter.processSingleSampleRaw (sample);
        else
            return sample;
    }

private:
    MyParameters* params;

    juce::IIRFilter filter;

    juce::ADSR filterEnv;
    juce::ADSR::Parameters filterParams;

    /**
     Updates the parameters of the filter based on the user params object and the LFO.
        
     @param sampleRate The current sample rate, needed for correctly setting up the filter coefficients
     @param lfoAppliesToFilterFreq Specifies whether the LFO should be applied to the frequency
     @param lfoAppliesToFilterQ Specifies whether the LFO should be applied to the resonance
     @param lfoSample The relevant sample generated by the LFO
     */
    void updateParams (float sampleRate, bool lfoAppliesToFilterFreq, bool lfoAppliesToFilterQ, float lfoSample)
    {
        // Setting the filter parameters from the user editable parameters
        filterParams.attack = *params->filterAttack;
        filterParams.decay = *params->filterDecay;
        filterParams.sustain = *params->filterSustain;
        filterParams.release = *params->filterRelease;
        filterEnv.setParameters (filterParams);
        
        float freq = getFilterFrequency (lfoAppliesToFilterFreq, lfoSample);
        float q = getFilterQ (lfoAppliesToFilterQ, lfoSample);

        float envVal = filterEnv.getNextSample();

        // Apply the filter to the Q value if that is selected in the user params.
        if (params->filterAppliesTo->getIndex() == 1)
            q = std::max (envVal * q, 0.01f);

        switch (int (*params->filterType))
        {
            case 1: setHighPassCoefficients (sampleRate, freq, q, envVal); break;
            default: setLowPassCoefficients (sampleRate, freq, q, envVal);
        }
    }

    /**
     Gets the filter frequency from the user params and applies the LFO if necessary.
     
     The LFO is applied by first finding the minimum distance from the intended frequency and 20Hz and 20kHz. This is
     the maximum allowable difference that we can swing the frequency value by so the LFO is mutiplied by this value
     and added to the selected frequency.

     @param applyLfo Whether to apply the LFO here.
     @param lfoSample The relevant sample generated by the LFO
     */
    float getFilterFrequency (bool applyLfo, float lfoSample)
    {
        float freq = *params->filterFreq;

        if (applyLfo)
        {
            float maxAllowedDiff = std::min (std::fabs (freq - 20.0f), std::fabs (20000.0f - freq));
            return freq + (lfoSample * maxAllowedDiff);
        }
        else
        {
            return freq;
        }
    }

    /**
     Gets the filter resonance value from the user params and applies the LFO if necessary.
     
     The LFO will simply cause the Q value to swing between 0 and twice the user setting.
     
     @param applyLfo Whether to apply the LFO here.
     @param lfoSample The relevant sample generated by the LFO
     */
    float getFilterQ (bool applyLfo, float lfoSample)
    {
        float q = *params->filterQ;

        if (applyLfo)
        {
            return q + (lfoSample * q);
        }
        else
        {
            return q;
        }
    }

    /**
     Sets the filter up with low pass coefficients.
     
     @param sampleRate The current sample rate, needed for correctly setting up the filter coefficients
     @param freq Specifies the frequency to set the filter at
     @param q Specifies the resonance to set the filter at
     @param envVal The relevant modifier value generated by the envelope
     */
    void setLowPassCoefficients (float& sampleRate, float& freq, float& q, float& envVal)
    {
        // Protection against going below 20Hz
        if (params->filterAppliesTo->getIndex() == 0)
            freq = std::max (envVal * freq, 20.0f);

        filter.setCoefficients (juce::IIRCoefficients::makeLowPass (sampleRate, freq, q));
    }

    /**
     Sets the filter up with high pass coefficients.
     
     @param sampleRate The current sample rate, needed for correctly setting up the filter coefficients
     @param freq Specifies the frequency to set the filter at
     @param q Specifies the resonance to set the filter at
     @param envVal The relevant modifier value generated by the envelope
     */
void setHighPassCoefficients (float& sampleRate, float& freq, float& q, float& envVal)
    {
        // Protection against going beyond 20kHz
        if (params->filterAppliesTo->getIndex() == 0)
            freq = 20000.0f - (envVal * (20000.0f - freq));

        filter.setCoefficients (juce::IIRCoefficients::makeHighPass (sampleRate, freq, q));
    }
};

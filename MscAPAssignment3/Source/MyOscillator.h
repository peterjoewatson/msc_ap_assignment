/*
  ==============================================================================

    MyOscillator.h
    Created: Apr/May 2022
    Author: B191392
 
    This implements an oscillator that can be switched between various different
    types. Its frequency is controlled by the target note frequency that is set
    in startNote but can also be modified by octave and cent values in the
    user parameters by the LFO. The following parameters are available:
 
    * oscType: See below for available types
    * oscGain: Sets a volume for this oscillator - relevant when it is summed with others
    * oscOctave: integer value from -2 to 2 that can pitch the oscillator up or down octave values relative to the note frequency
    * oscCents: float value from -100 to 100 that can pitch the oscillator up or down cent values relative to the note frequency
    * oscPush: Only applicable to the Push Square type. See below for more details.
 
    The oscillator has 4 classic types: Sine, Triangle, Square and Sawtooth and two
    additional special types. Better Sawtooth implements an anti-aliasing technique.
    The push square type pushes a sine wave through a tanh function with a user
    controllable push value that amplifies the sine wave before pushing it though
    the tanh. This causes a soft clipping to occur at lower push values and
    approaches a slightly rounded square wave at higher push values.

  ==============================================================================
*/

#pragma once

#include <cmath>
#include "MyParameters.h"

class MyOscillator
{
public:
    MyOscillator (juce::AudioParameterChoice* _oscType,
                  std::atomic<float>* _oscGain,
                  std::atomic<float>* _oscOctave,
                  std::atomic<float>* _oscCents,
                  std::atomic<float>* _oscPush) :
    oscType (_oscType), oscGain (_oscGain), oscOctave (_oscOctave), oscCents (_oscCents), oscPush (_oscPush)
    {
        // empty
    }

    
    /**
     @param _frequency The target frequency that the oscillator is set to
     */
    void startNote (float _frequency)
    {
        noteFrequency = _frequency;
    }

    
    /**
     This calculates the frequency based off the target note frequency, the user params and the LFO.
        
            If the LFO applies to the frequency then the applicable depth of the sweep is considered to be whichever is the smaller
            of the distance between the target and 20Hz or the target and 20kHz. The LFO sample is then multiplied by this.
     
            The user can also specify an octave value that decides if the actual frequency should be 1 or 2 octaves higher or lower
            than the target frequency.
                            
            The user can also specify a number of cents away from the target note frequency the oscillator should be. If
            the LFO is to be applied to cents rather than the frequency then the LFO sample is multipled by 100 (a fixed
            maximum deviation) and added to the user provided value.
                            
            
     @param sampleRate The sample rate of the system
     @param lfoAppliesToFrequency True if the LFO should affect the oscillator frequency, false otherwise
     @param lfoAppliesToCents True if the LFO should affect the oscillator cents parameter
     @param lfoSample  The sample generated by the LFO
     */
    void updateParams (float sampleRate, bool lfoAppliesToFrequency, bool lfoAppliesToCents, float lfoSample)
    {
        float lfoFrequency;
        if (lfoAppliesToFrequency)
        {
            float maxAllowedDiff = std::min (std::fabs (noteFrequency - 20.0f), std::fabs (20000.0f - noteFrequency));
            lfoFrequency = noteFrequency + (lfoSample * maxAllowedDiff);
        }
        else
        {
            lfoFrequency = noteFrequency;
        }

        float octaveFrequency;
        switch (int (*oscOctave))
        {
            case -2:
                octaveFrequency = lfoFrequency / 4.0f;
                break;
            case -1:
                octaveFrequency = lfoFrequency / 2.0f;
                break;
            case 1:
                octaveFrequency = lfoFrequency * 2.0f;
                break;
            case 2:
                octaveFrequency = lfoFrequency * 4.0f;
                break;
            default:
                octaveFrequency = lfoFrequency;
        }

        float oscCentsVal = *oscCents;
        if (lfoAppliesToCents)
            oscCentsVal = oscCentsVal + (lfoSample * 100);

        float actualFrequency = octaveFrequency * std::pow (2.0f, (oscCentsVal / 1200.0f));

        updatePhaseDelta (actualFrequency, sampleRate);
    }

    float getNextSample()
    {
        float sample;
        switch (int (*oscType))
        {
            case 0:
                sample = getNextSampleSine();
                break;
            case 1:
                sample = getNextSampleTriangle();
                break;
            case 2:
                sample = getNextSampleSquare();
                break;
            case 3:
                sample = getNextSampleSaw();
                break;
            case 4:
                sample = getNextSamplePushSquare();
                break;
            case 5:
                sample = getNextSampleBetterSaw();
                break;
            default:
                sample = getNextSampleTriangle();
        }

        return *oscGain * sample;
    }

private:
    juce::AudioParameterChoice* oscType;
    std::atomic<float>* oscGain;
    std::atomic<float>* oscOctave;
    std::atomic<float>* oscCents;
    std::atomic<float>* oscPush;

    float noteFrequency;

    float phaseDelta;
    float phase = 0;

    float pi2 = 2 * M_PI;

    float getNextSampleSine()
    {
        return sin (pi2 * getNextPhase());
    }

    float getNextSampleTriangle()
    {
        return (fabs (getNextPhase() - 0.5) * 4) - 1;
    }

    float getNextSampleSquare()
    {
        if (getNextPhase() < 0.5)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }

    float getNextSampleSaw()
    {
        return (getNextPhase() * 2) - 1;
    }

    float getNextSamplePushSquare()
    {
        return tanh (*oscPush * getNextSampleSine());
    }

    float getNextSampleBetterSaw()
    {
        // TODO: Actually do it!
        return getNextSampleSaw();
    }

    float getNextPhase()
    {
        phase += phaseDelta;

        if (phase > 1)
        {
            phase -= 1;
        }

        return phase;
    }

    void updatePhaseDelta (float frequency, float sampleRate)
    {
        phaseDelta = frequency / sampleRate;
    }
};
